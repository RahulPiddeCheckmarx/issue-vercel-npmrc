#!/groovy
@Library('cx-jenkins-pipeline-kit') _
@Library('team17-jenkins-library')

import java.time.*

def stageResults = [:]
def ipAddressClean, ipAddressUpgrade
def vmNameClean = "Smoke-CI-Clean-main-${BUILD_ID}-" + UUID.randomUUID().toString()
def installationLogsClean = "${vmNameClean}_Build_${env.BUILD_NUMBER}_Installation"
def testsCapturesClean = "${vmNameClean}_Build_${env.BUILD_NUMBER}_TestsCaptures"
def vmNameUpgrade = "Smoke-CI-Upgrade-main-${BUILD_ID}-" + UUID.randomUUID().toString()
def installationLogsUpgrade = "${vmNameUpgrade}_Build_${env.BUILD_NUMBER}_Installation"
def testsCapturesUpgrade = "${vmNameUpgrade}_Build_${env.BUILD_NUMBER}_TestsCaptures"
def installationFilePath = "C:\\CI-slave\\checkmarx\\installation\\"
def nextTemplate
def stageOwner
def parentName
def testVersion
//Tests param
def hostNameToReplace = "2016CItemplate"
def vmNameUpgradeUpdated = vmNameUpgrade.split("-")[0] + vmNameUpgrade.split("-")[3]
def vmNameCleanUpdated = vmNameClean.split("-")[0] + vmNameClean.split("-")[2] + "-${env.BUILD_NUMBER}"
def queryUpdateComponentConfigurations = "UPDATE [CxDB].[dbo].[CxComponentConfiguration]  SET [Value]=replace([Value],'${hostNameToReplace}','${vmNameUpgradeUpdated}')"
//allure report parameters
def cleanResults = null
def upgradeResults = null
def allureResults = ''
//Devops
def teamsWebHookUrl_9_x = 'https://outlook.office.com/webhook/ae8d392d-8c74-4e70-85a8-0d9ac7ed751b@6677be72-cda1-47e8-ae4a-320b4692c7d7/JenkinsCI/6f60ef406b8a4ffcbe1c7fe8368783a8/4ff5549c-c3bd-4f41-a44a-50e1241ac1d2'
def teamsWebHookUrl_master = 'https://checkmarx.webhook.office.com/webhookb2/6e554f55-bba7-4d46-8483-d439bb7a20d0@6677be72-cda1-47e8-ae4a-320b4692c7d7/JenkinsCI/3e00fdd8f7284e769cce2f821e4a2c4f/d76815a5-6beb-4643-879e-63975e39f117'
def consulClusterAdress = "10.32.2.208"
def grafanaDashboardId = '8O89QLlZk'
def baseGrafanLink = kit.getGrafanaLinkByDashboard(grafanaDashboardId) + '?var-server='
def suportedACMigration = '9.2.0'
// --------------------------------------- Variables of Kibana view -------------------------------------------------------
def LocalDateTime beatsInstallStartTimeObj = LocalDateTime.now()
beatsInstallStartTimeObj = beatsInstallStartTimeObj.minusHours(3)
// ------------------------------------- END variables of Kibana view -----------------------------------------------------

def allureLinkCreate(url, title){
    def link = "<a href='%s' title=\"Allure Report Link\"> <img src=\"/plugin/allure-jenkins-plugin/img/icon.png\" width=\"16\" height=\"16\" title='%s' style=\"font-size: 16px; text-decoration: none\">%s</a><br/>";
    def sb = new StringBuilder();
    kit.Info_Msg("allure link is - ${url}")
    sb.append(String.format(link, url, title, title));
    return sb
}

pipeline {
    parameters {
        string(name: 'buildDef', defaultValue: 'CxSAST.Main.Release.Setup', description: 'Tfs build definition name')
        string(name: 'sastVersion', defaultValue: '', description: 'Tfs build version folder name, example: CxSAST.Main.Release.Setup_8.8.0.1343')
        string(name: 'majorVersion', defaultValue: '', description: 'CxSAST major version. example: 9.0.0')
        string(name: "installationType",defaultValue: "All", description: "Clean or Upgrade or All for both installations")
        string(name: "cleanTemplate",defaultValue: "dynamicSmokeClean-2016-dotnet_6.0.5-only-java17jre", description: "Template for clean installation")
        string(name: "upgradeTemplate",defaultValue: "SmokeDynamicUpgrade-2012-9.4.0-Java17-dotnet6-ATDT-newPass_noMnO", description: "Template for upgrade installation")
        string(name: "ram",defaultValue: "16000", description: "Server memory")
        string(name: "cpu",defaultValue: "8", description: "")
        string(name: "provider",defaultValue: "VMWARE", description: "IAAS platform to be used")
        string(name: "decommissionPeriod",defaultValue: "3 hour", description: "Decommission period")
        string(name: "vmwareNetwork",defaultValue: "Lab", description: "vmware network for new VMs")
        string(name: "revisionLink",defaultValue: "none", description: "")
        string(name: "elasticSearchVersion",defaultValue: "9.0.0", description: "ElasticSearch version for dashboard report KPI")
        string(name: "automationBranch",defaultValue: "master", description: "Automation branch")
        //choice(name: 'automationBranch', choices: ['master','9.4.0-applitools', 'report_portal','9.2.0i','9.3.0','9.4.0', '9.3-WO-NQM','9.0.0-QM', '9.0.0','8.9.0'], description: ' master ->For CX 8.8.X 8.7.0 -> For CX 8.7.X 8.6.0 -> For CX 8.6.X')
        choice(name: 'browser', choices: ['CHROME', 'FIREFOX', 'IE', 'EDGE'], description: 'CHROME | FIREFOX | IE | EDGE')
        booleanParam(name: 'doNotDeleteVMinPost', defaultValue: false, description: 'If selected VM will be not deleted after process finished')
        booleanParam(name: "fipsEnabled", defaultValue: true, description: "FIPS will not be enabled by default. Might cause issues in 8.9")
        booleanParam(name: 'isSsl', defaultValue: true, description: 'If selected SSL recored and tested will be invoked')
        booleanParam(name: 'isLDAP', defaultValue: false, description: 'If selected LDAP will be configured and tested will be invoked')
        booleanParam(name: 'triggerCI', defaultValue: true, description: 'If selected CI pipelines will be triggered')
        booleanParam(name: 'isRunBalanced', defaultValue: false, description: 'If selected Balanced pipelines will be triggered')
        booleanParam(name: 'installBeats', defaultValue: true, description: 'If selected Beats are installed')
        booleanParam(name: 'isPrivateBuild', defaultValue: false, description: 'If this build is private build')
        booleanParam(name: 'isOSA', defaultValue: false, description: 'If to mark sast installation as ready for qa')
        booleanParam(name: 'useLegacyEngineService', defaultValue: false, description: 'If the test pipeline uses legacy engine service')
        booleanParam(name: 'extendCiLogs', defaultValue: false, description: 'If the CI process is using the extended json logs format')
        string(name: "parentBuildNumber",defaultValue: "0", description: " From Smoke = > parentBuildNumber")
        string(name: "installationLicensePath",defaultValue: "C:\\LIC\\license.cxl", description: "Full path to installation license file")
        string(name: "installationSqlServer",defaultValue: "localhost\\SQLEXPRESS", description: "Instance of sql server for installation")
        string(name: "installationSqlUser",defaultValue: "test", description: "Username for sql server for installation")
        string(name: "installationSqlPassword",defaultValue: "Cx123456", description: "Password for sql server user for installation")
        string(name: "TriggeredArtifactoryPath", defaultValue: '', description: "full atrifactory repository path to the new artifacts that triggerd the pipeline")
        string(name: "TFS_BUILD_ID",defaultValue: "0", description: "TFS pipelines run ID")
        string(name: "TFS_EMAIL_OWNER",defaultValue: "", description: "Owner of the commit to trigger the jenkins job")
    }
    agent { node { label 'install01' } }
    options {
        timestamps()
        timeout(time: 3, unit: 'HOURS')
        skipDefaultCheckout()
        ansiColor('xterm')
        buildDiscarder(logRotator(daysToKeepStr: '60', numToKeepStr: '50'))
    }
    stages {
        stage('Cleanup') {
            steps {
                script {
                    environment {
                        STAGE_NAME_FAILED = "Cleanup"
                        PIPELINE_STATUS = ""
                    }
                    deleteDir()
                    def upstream = currentBuild.rawBuild.getCause(hudson.model.Cause$UpstreamCause)
                    echo upstream?.shortDescription
                }
            }
        }

        stage('Pipeline Info') {
            steps {
                script {
                    env.MAILING_LIST = "Alonr,cxsastcoreautomation@checkmarx.onmicrosoft.com"
                    env.FULL_MAIL_LIST = "${TFS_EMAIL_OWNER},${env.MAILING_LIST}"
                    sast_smoke_mail.inProgress("SAST Smoke Dynamic CI", BUILD_ID, env.FULL_MAIL_LIST, TFS_BUILD_ID, BUILD_URL)
                    setPipelineInfo(sastVersion, buildDef)
                    majorVersion = sastVersion.substring(sastVersion.indexOf('_') + 1, sastVersion.lastIndexOf('.'))
                    parentName = BUILD_TAG.replace('jenkins-','')
                    testVersion = lab.setTestJob(automationBranch)
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    kit.healthCheck()
            }
        }
        }

        stage('Validate Params') {
            steps {
                script {
                    if(sastVersion.contains('9.6')) {
                        jenkinsHelper.replaceParam('upgradeTemplate','SmokeDynamicUpgrade-2012-9.4.0-Java17-dotnet6-ATDT-newPass_noMnO',"Template with installed SAST to full automation tests")
                        }
                    }
                }
            }

        stage('Clean & Upgrade Parallel process') {
            parallel {
                stage('Clean') {
                    when {
                        expression { installationType == 'All' || installationType == 'Clean' }
                    }
                    stages {
                        stage('Create VM') {
                            steps {
                                script {
                                    createVM(vmNameClean, ipAddressClean, cleanTemplate)
                                    ipAddressClean = kit.getIpAddress(vmNameClean, provider)
//                                    kit.renameMachine(ipAddressClean, "sm-ms-cl-${BUILD_NUMBER}", "WIN2012-ENV9-B")
//                                    sleep(60)
//                                    kit.startJenkinsAgentOnClient(ipAddressClean, vmNameClean)

                                }
                            }
                            post {
                                failure {
                                    script {
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Clean_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }
                        stage('Download CxSAST') {
                            agent { node { label vmNameClean } }
                            steps {
                                script {
                                    kit.smokeDownloadArtifactsNexus(installationFilePath, false)
                                    if (fipsEnabled == 'true') {
                                        lab.executeBatCommand("reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\FipsAlgorithmPolicy\" /v \"enabled\" /t \"REG_DWORD\" /d \"1\" /f")
                                    }
                                }
                            }
                            post {
                                failure {
                                    script {
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Clean_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Devops Actions') {
                            agent { node { label vmNameClean } }
                            steps {
                                script {
                                    runDevopsActions(vmNameClean, ipAddressClean, consulClusterAdress)
                                }
                            }
                        }

                        stage('Install CxSAST') {
                            agent { node { label vmNameClean } }
                            steps {
                                script {
                                    def destination = installationFilePath + "CxSetup.exe"
                                    kit.installCheckmarxSastAIO(false, destination, installationLicensePath, installationSqlServer, installationSqlUser, installationSqlPassword, "BI=0")
                                    if (params.useLegacyEngineService)
                                        bat '\\\\storage\\qa\\ScriptsForJenkins\\useLegacyEngineService.bat'
                                    if (params.extendCiLogs)
                                        bat '\\\\storage\\qa\\ScriptsForJenkins\\EnableJsonlogs.bat'
                                }
                            }
                            post {
                                failure {
                                    script {
                                        kit.zipStashInstallationLogs(installationLogsClean)
                                        // kit.failedSmokeEmailNotification(sastVersion, 'Smoke Installation Clean','tal.levi@checkmarx.com, elaad.adar@checkmarx.com')
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Clean_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Post Install Verification') {
                            agent { node { label vmNameClean } }
                            steps {
                                bat "git config --global core.longpaths true"
                                //for git Filename too long exception (Multibranch)
                                git branch: automationBranch, credentialsId: '15f8e7b7-6ce7-44c0-b151-84f99ffa7aed', poll: false, url: 'http://tfs2018app.dm.cx:8080/tfs/DefaultCollection/Automation/_git/Checkmarx-Reactor'
                                bat """mvn -q clean install -Drun.verification=true -Djob.name=${job_name} -Drun.useLegacyEngineService=${useLegacyEngineService}"""
                                script {
                                    lab.enableOsa(ipAddressClean)
                                }
                            }
                            post {
                                failure {
                                    script {
                                        kit.zipStashInstallationLogs(installationLogsClean)
                                        // kit.failedSmokeEmailNotification(sastVersion, 'Smoke Installation Verification On Clean','tal.levi@checkmarx.com, elaad.adar@checkmarx.com')
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Clean_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Configure LDAP') {
                            when { expression { isLDAP == 'true' } }
                            agent { node { label vmNameClean } }
                            steps {
                                git branch: automationBranch, credentialsId: '15f8e7b7-6ce7-44c0-b151-84f99ffa7aed', poll: false, url: 'http://tfs2018app.dm.cx:8080/tfs/DefaultCollection/Automation/_git/Checkmarx-System-Test'
                                bat """cd %cd%\\CX-E2E-Test & mvn -q clean test -Dtest=com.cx.automation.test.sanity.CxLdapFlow -Denv=external_env -DfailIfNoTests=false -Dmaven.test.failure.ignore=false -Ddriver.browser=${Browser}"""
                            }
                        }

                        stage("Trigger Smoke Tests") {
                            steps {
                                script {
                                    kit.Info_Msg("triggering Smoke Tests")
                                    cleanResults = build job: "${testVersion}", parameters: [
                                            string(name: 'isSsl', value: "${isSsl}"),
                                            string(name: 'vmLabel', value: "${vmNameClean}"),
                                            string(name: 'automationBranch', value: "${automationBranch}"),
                                            string(name: 'Browser', value: "${Browser}"),
                                            string(name: 'sastVersion', value: "${sastVersion}"),
                                            string(name: 'installationLogs', value: "${installationLogsClean}"),
                                            string(name: 'hostname', value: "${vmNameCleanUpdated}"),
                                            string(name: 'testsCaptures', value: "${testsCapturesClean}"),
                                            string(name: 'parentUrl', value: "${BUILD_URL}"),
                                            string(name: 'parentName', value: "${parentName}"),
                                            string(name: 'serverIP', value: "${ipAddressClean}"),
                                            booleanParam(name: 'useLegacyEngineService', value: "${useLegacyEngineService}"),
                                            string(name: 'testsLabel', value: "Clean")],
                                            wait: true, propagate: false
                                    kit.Info_Msg("Clean Tests '${cleanResults.fullDisplayName}' took ${cleanResults.durationString} to finish and results are '${cleanResults.result}' \n Link to Allure Report for '${cleanResults.fullDisplayName}' located - '${cleanResults.absoluteUrl}allure/'")
                                    if (!cleanResults.result.equals("SUCCESS")) {
                                        env.STAGE_NAME_FAILED = "${cleanResults.buildVariables.STAGE_NAME_FAILED}"
                                        kit.Info_Msg("failed stage was: ${env.STAGE_NAME_FAILED}")
                                        stageResults."Clean__Tests_${cleanResults.buildVariables.STAGE_NAME_FAILED}" = "Failure"
                                        error "Failure during Tests on ${STAGE_NAME}"
                                    }
                                }
                            }
                        }
                    }
                    post {
                        always {
                            script {
                                if (cleanResults.result == 'FAILURE' || cleanResults.result == 'SUCCESS') {
                                    kit.Info_Msg("adding ${STAGE_NAME} Test stage Allure report to description")
                                    allureResults += allureLinkCreate("${cleanResults.absoluteUrl}allure/", "${STAGE_NAME} result:${cleanResults.result}")
                                }
                                copyArtifacts fingerprintArtifacts: true, optional: true, projectName: "${cleanResults.projectName}", selector: specific("${cleanResults.number}")
                            }
                        }
                    }
                }
                stage('Upgrade') {
                    when { expression { installationType == 'All' || installationType == 'Upgrade' } }
                    stages {
                        stage('Create VM') {
                            steps {
                                script {
                                    createVM(vmNameUpgrade, ipAddressUpgrade, upgradeTemplate)
                                    ipAddressUpgrade = kit.getIpAddress(vmNameUpgrade, provider)
                                }
                            }
                            post {
                                failure {
                                    script {
                                        stageResults."Upgrade_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Update CxSAST Data Base') {
                            when { expression { isLDAP == 'true' } }
                            agent { node { label vmNameUpgrade } }
                            steps {
                                script {
                                    bat """sqlcmd -S ${installationSqlServer} -U ${installationSqlUser} -P ${installationSqlPassword} -Q "${queryUpdateComponentConfigurations}" """
                                }
                            }
                        }

                        stage('Configure LDAP before upgrade') {
                            when { expression { isLDAP == 'true' } }
                            agent { node { label vmNameUpgrade } }
                            steps {
                                git branch: "8.9.0", credentialsId: '15f8e7b7-6ce7-44c0-b151-84f99ffa7aed', poll: false, url: 'http://tfs2018app.dm.cx:8080/tfs/DefaultCollection/Automation/_git/Checkmarx-System-Test'
                                bat """mvn -q clean test -Dtest=com.cx.automation.test.ui.ldapservers.CreateActiveDirectoryServerStandAlone#createADLDAPWithSynchronizationNoDeletion -Denv=external_env -Ddriver.browser=${Browser} -DfailIfNoTests=false -Dmaven.test.failure.ignore=false"""
                            }
                        }

                        stage('Download CxSAST') {
                            agent { node { label vmNameUpgrade } }
                            steps {
                                script {
                                    kit.smokeDownloadArtifactsNexus(installationFilePath, majorVersion <= suportedACMigration)
                                    if (fipsEnabled == 'true') {
                                        lab.executeBatCommand("reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\FipsAlgorithmPolicy\" /v \"enabled\" /t \"REG_DWORD\" /d \"1\" /f")
                                    }
                                }
                            }
                            post {
                                failure {
                                    script {
                                        stageResults."Upgrade_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Devops Actions') {
                            agent { node { label vmNameUpgrade } }
                            steps {
                                script {
                                    runDevopsActions(vmNameUpgrade, ipAddressUpgrade, consulClusterAdress)
                                }
                            }
                        }

                        stage('Install CxSAST') {
                            agent { node { label vmNameUpgrade } }
                            steps {
                                script {
                                    def destination
                                    echo "majorVersion: ${majorVersion}"
                                    if (majorVersion != '8.9.0' && majorVersion <= suportedACMigration) {
                                        destination = installationFilePath + "CxSetup.AC_and_Migration.exe"
                                        kit.runAcMigration(destination)
                                    }
                                    destination = installationFilePath + "CxSetup.exe"
                                    kit.installCheckmarxSastAIO(true, destination, installationLicensePath, installationSqlServer, installationSqlUser, installationSqlPassword)
                                    if (params.useLegacyEngineService)
                                        bat '\\\\storage\\qa\\ScriptsForJenkins\\useLegacyEngineService.bat'
                                    if (params.extendCiLogs)
                                        bat '\\\\storage\\qa\\ScriptsForJenkins\\EnableJsonlogs.bat'

                                    if ( automationBranch == 'master') {
                                        String sqlStr = '".\\sqlexpress" -d "CxDB" -E -Q "update [CxDB].[accesscontrol].[Tenants] set [PasswordExpiryDays]=2000 where [Name] = \'Checkmarx\'"'
                                        bat "sqlcmd -S ${sqlStr}"
                                        bat """iisreset"""
                                    }
                                }
                            }
                            post {
                                failure {
                                    script {
                                        kit.zipStashInstallationLogs(installationLogsUpgrade)
                                        // kit.failedSmokeEmailNotification(sastVersion, 'Smoke Installation Upgrade','tal.levi@checkmarx.com, elaad.adar@checkmarx.com')
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Upgrade_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage('Save DB snapshot') {
                            agent { node { label vmNameUpgrade } }
                            steps {
                                script {
                                    automation.createAtdtDbSnapshot()
                                }
                            }
                            post {
                                failure {
                                    script { kit.Send_Email_Private('anna.pomerchuk@checkmarx.com', "Fail to run detach-attach DB", "Fail to run detach-attach DB") }
                                }
                            }
                        }

                        stage('Post Install Verification') {
                            agent { node { label vmNameUpgrade } }
                            steps {
                                bat """iisreset""" // added as a workaround by request of Tal Landa
                                bat "git config --global core.longpaths true"
                                //for git Filename too long exception (Multibranch)
                                git branch: automationBranch, credentialsId: '15f8e7b7-6ce7-44c0-b151-84f99ffa7aed', poll: false, url: 'http://tfs2018app.dm.cx:8080/tfs/DefaultCollection/Automation/_git/Checkmarx-Reactor'
                                bat """mvn -q clean install -Drun.verification=true -Djob.name=${job_name} -Drun.useLegacyEngineService=${useLegacyEngineService}"""
                                script {
                                    lab.enableOsa(ipAddressUpgrade)
                                }
                            }
                            post {
                                failure {
                                    script {
                                        kit.zipStashInstallationLogs(installationLogsUpgrade)
                                        kit.failedSmokeEmailNotification(sastVersion, 'Smoke Installation Verification On Upgrade', 'CxEngine@checkmarx.com,CxAppDev@checkmarx.com,CxSEG.Installer@checkmarx.com, arkadys@codevalue.net,CxAppDev@checkmarx.com,Albert.Ribakovsky@checkmarx.com,Ilan.Shtokhamer@checkmarx.com,moran.katz@checkmarx.com')
                                        env.STAGE_NAME_FAILED = "${STAGE_NAME}"
                                        stageResults."Upgrade_${STAGE_NAME}" = "Failure"
                                    }
                                }
                            }
                        }

                        stage("Trigger Smoke Tests") {
                            steps {
                                script {
                                    kit.Info_Msg("triggering Smoke Tests")
                                    upgradeResults = build job: "${testVersion}", parameters: [
                                            string(name: 'isSsl', value: "false"),
                                            string(name: 'vmLabel', value: "${vmNameUpgrade}"),
                                            string(name: 'automationBranch', value: "${automationBranch}"),
                                            string(name: 'browser', value: "${browser}"),
                                            string(name: 'sastVersion', value: "${sastVersion}"),
                                            string(name: 'installationLogs', value: "${installationLogsUpgrade}"),
                                            string(name: 'hostname', value: "${vmNameUpgradeUpdated}"),
                                            string(name: 'testsCaptures', value: "${testsCapturesUpgrade}"),
                                            string(name: 'parentUrl', value: "${BUILD_URL}"),
                                            string(name: 'parentName', value: "${parentName}"),
                                            string(name: 'serverIP', value: "${ipAddressUpgrade}"),
                                            booleanParam(name: 'useLegacyEngineService', value: "${useLegacyEngineService}"),
                                            string(name: 'testsLabel', value: "Upgrade")],
                                            wait: true, propagate: false
                                    kit.Info_Msg("Upgrade Tests '${upgradeResults.fullDisplayName}' took '${upgradeResults.durationString}' to finish and results are '${upgradeResults.result}' \n Link to Allure Report for '${upgradeResults.fullDisplayName}' located - '${upgradeResults.absoluteUrl}allure/'")
                                    if (!upgradeResults.result.equals("SUCCESS")) {
                                        env.STAGE_NAME_FAILED = "${upgradeResults.buildVariables.STAGE_NAME_FAILED}"
                                        kit.Info_Msg("failed stage was: ${env.STAGE_NAME_FAILED}")
                                        stageResults."Upgrade_Tests_${upgradeResults.buildVariables.STAGE_NAME_FAILED}" = "Failure"
                                        error "Failure during Tests on ${STAGE_NAME}"
                                    }
                                }
                            }
                        }
                        stage('Prepare Template') {
                            steps {
                                script {
                                    def jenkinsLabel = installationType == 'Clean' ? vmNameClean : vmNameUpgrade
                                    def ipAddress = installationType == 'Clean' ? ipAddressClean : ipAddressUpgrade
                                    nextTemplate = prepareTemplate(provider, jenkinsLabel, ipAddress)
                                }
                            }
                        }

                        stage('Trigger CI') {
                            when { expression { triggerCI == 'true'} }
                            steps {
                                script{
                                    automation.determineJobsTrigger(sastVersion, automationBranch, false, elasticSearchVersion, Browser, buildDef, nextTemplate, TriggeredArtifactoryPath, env.BUILD_NUMBER, params.useLegacyEngineService, params.reRunJob,isRunBalanced)
                                }
                            }

                        }
                    }
                    post {
                        always {
                            script {
                                if (upgradeResults.result == 'FAILURE' || upgradeResults.result == 'SUCCESS') {
                                    kit.Info_Msg("adding ${STAGE_NAME} Test stage Allure report to description")
                                    allureResults += allureLinkCreate("${upgradeResults.absoluteUrl}allure/", "${STAGE_NAME} result:${upgradeResults.result}")
                                }
                                copyArtifacts fingerprintArtifacts: true, optional: true, projectName: "${upgradeResults.projectName}", selector: specific("${upgradeResults.number}")
                            }
                        }

                    }
                }
                stage('Linux') {
                    when {
                        expression { installationType == 'All' || installationType == 'Linux' }
                    }
                    stages {
                        stage('Trigger Linux Pipeline') {
                            steps {
                                script {
                                   // def linuxTemplates = ['template-Centos-7-dotnet6-docker', 'template-Fedora-34-dotnet6-docker', 'template-RedHat-7.9-dotnet6-docker','template-Ubuntu-18.04-dotnet6-docker','template-Ubuntu-20.04-dotnet6-docker','template-AmazonLinux-2-docker-dotnet6']
                                   // Random random = new Random();
                                   // int x = random.nextInt(6);
                                   // def linuxTemplate = linuxTemplates[x]
                                    def linuxTemplate = "template-Centos-7-dotnet6-docker"

                                    def engineConfigurations = ['docker-compose', 'docker', 'bare-metal-process', 'bare-metal-service']
                                    Random randomConfig = new Random ();
                                    int y = randomConfig.nextInt(4);
                                    def engineConfiguration = engineConfigurations [y]
                                    //def engineConfiguration = 'docker-compose'

                                    def Results = triggerLinuxSmoke(linuxTemplate,engineConfiguration)
                                    if (Results.result == 'FAILURE' || Results.result == 'SUCCESS') {
                                        kit.Info_Msg("adding ${STAGE_NAME} Test stage Allure report to description")
                                        allureResults += allureLinkCreate("${Results.absoluteUrl}allure/", "${STAGE_NAME} result:${Results.result}")
                                    }

                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Copy Installer Version To Nexus') {
            agent { node { label 'Sharks-CI-Main-Executor' } }
            when { expression { isPrivateBuild == 'false' } }
            steps {
                script {
                    destination = kit.getCxNexusUrl() + "/repository/CxSAST-Ready-For-QA/${buildDef}/${sastVersion}/"
                    kit.smokeDownloadArtifactsNexus(installationFilePath, false)
                    kit.uploadArtifactToNexusArtifactory(installationFilePath + "CxSetup.exe", destination)
                    try {
                        source = kit.getArtifactLinkFromNexusArtifactory("CxSast", sastVersion, "Summary.html")
                        kit.downloadArtifactFromNexusArtifactory(source, installationFilePath + "Summary.html")
                        kit.uploadArtifactToNexusArtifactory(installationFilePath + "Summary.html", destination)
                    } catch (Exception e) {
                        kit.Warning_Msg("Failed to upload Summary.html file to Nexus. Exception:\n" + e.toString())
                        currentBuild.result = 'UNSTABLE'
                    }
                    // the below IF condition is defined because the README.txt currently exist only on MAIN (9.2) and 9.0 versions
                    if (buildDef == "CxSAST.Main.Release.Setup" || buildDef == "CxSAST.900.Release.Setup" || buildDef == "CxSAST.900.HF.Release.Setup") {
                    try {
                        source = kit.getArtifactLinkFromNexusArtifactory("CxSast", sastVersion, "README.txt")
                        kit.downloadArtifactFromNexusArtifactory(source, installationFilePath + "README.txt")
                        kit.uploadArtifactToNexusArtifactory(installationFilePath + "README.txt", destination)
                    } catch (Exception e) {
                        kit.Warning_Msg("Failed to upload README.txt file to Nexus. Exception:\n" + e.toString())
                        currentBuild.result = 'UNSTABLE'
                    }
                  }
                }
            }
        }

        stage('Mark Artifacts as Ready-For-QA') {
            when { expression { automation.whenByInstallationType(installationType, cleanResults, upgradeResults) && isPrivateBuild == 'false' } }
            steps {
                script {
                    if(TriggeredArtifactoryPath != ""){
                        kit.tagSuccessArtifacts(TriggeredArtifactoryPath)
                    }
                }
            }
        }

        stage('Trigger CxSAST-AIO Docker Image Build') {
            when { expression { buildDef == 'CxSAST.900.Release.Setup'} }
            steps {
                build job: 'CxSast-AIO-Win2019-IMG-Creator', parameters: [string(name: 'sastVersion', value: "${sastVersion}")], wait: false
            }
        }
    }
    post {
        always {
            script {

                jenkinsHelper.replaceParam('isRunBalanced','false',"If selected Balanced pipelines will be triggered")
                if (stageResults.size() != 0){
                    for (element in stageResults) {
                        if (currentBuild.description == null){
                            currentBuild.setDescription("Failed on \"${element.key}\" stage");
                        }else {
                            currentBuild.setDescription("${currentBuild.description}<br/>Failed on \"${element.key}\" stage");
                        }
                    }
                    currentBuild.result='FAILURE'
                }
                if (currentBuild.description == null){
                    currentBuild.setDescription("${allureResults}")
                }else {
                    currentBuild.setDescription("${currentBuild.description}<br/>${allureResults}")
                }
                logstashSend failBuild: false, maxLines: 1000
                if ((installationType == 'All' || installationType == 'Clean') && ipAddressClean != null) {
                    try {
                        if (doNotDeleteVMinPost == 'false') {
                            if(TriggeredArtifactoryPath == 'nightly'){
                                kit.updateDecommissionPeriod(vmNameClean, "1 days")
                            }
                            else {
                                if (currentBuild.currentResult != 'SUCCESS') {
                                    kit.updateDecommissionPeriod(vmNameClean, "1 hour")
                                } else {
                                    deleteVm(provider, ipAddressClean, vmNameClean)
                                }
                            }
                        }
                    } catch (Exception e) {
                        kit.Warning_Msg("Upgrade VM - Fail to delete or to update decommission period. Exception:\n" + e.toString())
                        currentBuild.result = 'UNSTABLE'
                    }
                }

                if ((installationType == 'All' || installationType == 'Upgrade') && ipAddressUpgrade != null) {
                    try {
                        if (doNotDeleteVMinPost == 'false') {
                            if(TriggeredArtifactoryPath == 'nightly'){
                                kit.updateDecommissionPeriod(vmNameUpgrade, "1 days")
                            }
                            else {
                                if (currentBuild.currentResult != 'SUCCESS') {
                                    kit.updateDecommissionPeriod(vmNameUpgrade, "1 hour")
                                } else {
                                    deleteVm(provider, ipAddressUpgrade, vmNameUpgrade)
                                }
                            }
                        }
                    } catch (Exception e) {
                        kit.Warning_Msg("Upgrade VM - Fail to delete or to update decommission period. Exception:\n" + e.toString())
                        currentBuild.result = 'UNSTABLE'
                    }
                }
                try {
                    def source = kit.getArtifactLinkFromNexusArtifactory("CxSast", sastVersion, "Summary.html")
                    def destination = pwd() + "/Summary.html"
                    kit.downloadArtifactFromNexusArtifactory(source, destination)
                } catch (e) {
                    kit.Error_Msg("No Summery.html file to archive. Exception:\n" + e.toString())
                    currentBuild.result = 'UNSTABLE'
                }
                archiveArtifacts '*.zip, Summary.html'
                kit.Info_Msg("Update metrics Description View")
                try {
                    /*def resultClean = kit.returnKibanaLink ("${beatsInstallStartTimeObj}", vmNameClean, "cx-kibana.dm.cx")
                    def resultUpgrade = kit.returnKibanaLink ("${beatsInstallStartTimeObj}", vmNameUpgrade, "cx-kibana.dm.cx")*/
                    def resultDashboard = kit.returnKibanaDashboardLink ("${beatsInstallStartTimeObj}", env.BUILD_TAG, "cx-kibana.dm.cx")
                    def finalResultClean = '<a href="' + "${resultDashboard}" + '">Kibana dashboard View</a>'  + '<br>' + '<a target="_parent" href="' + "${ baseGrafanLink + vmNameClean }" + '">Grafana Clean View</a>' + '<br>' + '<a target="_parent" href="' + "${ baseGrafanLink + vmNameUpgrade }" + '">Grafana Upgrade View</a>' + '<br>'
                    dir ('HTMLReports') {
                        writeFile file:'index.html', text: "${finalResultClean}"
                    }
                    publishHTML (target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'HTMLReports', reportFiles: 'index.html', reportName: "Metrics Report"])
                } catch (e) {
                    kit.Error_Msg("Failed to commit Elastic link:\n" + e.toString())
                }
                
                kit.Info_Msg("Sending logs to Coralogix")
                coralogixSend privateKeyCredentialId: 'Coralogix',
                application: 'SAST-Automation',
                subsystem: "${env.JOB_NAME}",
                splitLogs: false
            }
        }
        success {
            script{

                sast_smoke_mail.success("SAST Smoke Dynamic CI", BUILD_ID, env.FULL_MAIL_LIST, TFS_BUILD_ID, BUILD_URL)

                env.STAGE_NAME_FAILED="success ${STAGE_NAME}"
                env.PIPELINE_STATUS = "success"
            }
        }
         failure {
             script {

                sast_smoke_mail.failed("SAST Smoke Dynamic CI", BUILD_ID, env.FULL_MAIL_LIST, TFS_BUILD_ID, BUILD_URL)
 
                def teamsWebHookUrl =  (automationBranch.toLowerCase() == "master") ? teamsWebHookUrl_master : teamsWebHookUrl_9_x
                try {
                    if (isPrivateBuild == 'false') {
                    kit.failureJenkinsTeamsMessage(teamsWebHookUrl, env.STAGE_NAME_FAILED, TriggeredArtifactoryPath)
                    }
                } catch (Exception e) {
                    kit.Warning_Msg("Failed to send notification. Exception:\n" + e.toString())
                }
             }
         }
        cleanup {
            script{
                kit.elkPost()
                cleanWs()
            }
        }
    }
}

def triggerLinuxSmoke(linuxTemplate,engineConfiguration) {
    def Results = build job: "Sharks-Core/linux-engine/smoke", parameters: [
            string(name: 'TFS_BUILD_ID', value: "latest"),
            string(name: 'version', value: "${sastVersion}"),
            string(name: 'buildRepo', value: "${buildDef}"),
            string(name: 'linuxEngineTemplate', value: "${linuxTemplate}"),
            string(name: 'engineConfiguration', value: "${engineConfiguration}"),
            string(name: 'sastTemplate', value: "${cleanTemplate}"),
            string(name: 'automationBranch', value: "${automationBranch}"),
            string(name: 'browser', value: "${Browser}"),
            string(name: 'installationSqlServer', value: "${installationSqlServer}"),
            string(name: 'installationSqlUser', value: "${installationSqlUser}"),
            string(name: 'installationSqlPassword', value: "${installationSqlPassword}"),
            string(name: 'decommissionPeriod', value: "${decommissionPeriod}"),
            booleanParam(name: 'extendVMsUponSuccess', value: "${doNotDeleteVMinPost}"),
            booleanParam(name: 'abortToEffectParamChange', value: "false"),
            booleanParam(name: 'deleteVMsEvenAfterFailure', value: "false")],
            wait: true, propagate: false
    if (!Results.result.equals("SUCCESS")) {
        error "Failure during Tests on ${STAGE_NAME}"
    }

    return Results
}

def setPipelineInfo(sastVersion, buildDef) {
    if (sastVersion == null || sastVersion == "") {
        if (buildDef == null || buildDef == "") {
            kit.Error_Msg("You must specify CxSAST version or at least build definition in build parameters.")
            error 'You must specify CxSAST version or at least build definition in build parameters.'
        }
        sastVersion = kit.getLatestArtifactVersionFromNexusArtifactory("CxSast", buildDef, "CxSetup.exe")
        kit.Info_Msg("Setting Jenkins version parameter to last successful build - version: [${sastVersion}]")
        def build = currentBuild.getRawBuild()
        def newVersionParameter = new StringParameterValue('sastVersion', "$sastVersion", "Build full sastVersion wasn't specified-latest build of ${buildDef} was retrieved")
        ParametersAction paramActions = build.actions.find {
            it instanceof ParametersAction
        }
        build.replaceAction(paramActions.merge(new ParametersAction(newVersionParameter)))
    }
    majorVersion = sastVersion.substring(sastVersion.indexOf('_') + 1, sastVersion.lastIndexOf('.'))
    sh 'printenv'
    currentBuild.description = sastVersion
    env.BUILD_TRIGGER_BY = "${currentBuild.getBuildCauses()[0].shortDescription}"
    currentBuild.description +=  "${env.BUILD_TRIGGER_BY}<br/>"
}

private void createVM(java.lang.String vmName, ipAddress, template) {
    stageOwner = "CxDevOps@checkmarx.com"
    kit.Info_Msg("Stage Owner: $stageOwner")
    kit.Create_Vm_Terraform(vmName, template, ram, cpu, provider, decommissionPeriod, "Auto", "SAST-Auto-CI", vmwareNetwork)
    ipAddress = kit.getIpAddress(vmName, provider)
    if (isLDAP == 'true') {
        kit.Cx_Join_To_Domain(vmName, ipAddress)
    }
    kit.Create_Jenkins_Slave_On_Master(vmName)
    kit.Start_Jenkins_Slave_On_Windows_Pstools(ipAddress, vmName)
}

def runDevopsActions(vmName, ipAddress, consulClusterAdress){
   // task 'FileBeat'
    if ((installBeats == 'true') && (isPrivateBuild == 'false')) {
        try {
            kit.changeFileBeatTags("'${vmName}','${env.BUILD_TAG}'")
        } catch (Exception e) {
            Error_Msg("FileBeat process in clean stage FAILED: " + e)
            error "FileBeat process in clean stage FAILED: ${e}"
        }
    } else {
        kit.turnOffFilebeat()
    }
   // task 'WMI exporter'
    try {
        kit.installWmiExporter(fipsEnabled)
    } catch (Exception e) {
        Info_Msg("Failed to install WMI exporter")
    }
   // task 'Consul Agent'
    try {
        kit.installConsulAgent(ipAddress, vmName, consulClusterAdress)
    } catch (Exception e) {
        Info_Msg("Failed to install Consul Agent")
    }
}